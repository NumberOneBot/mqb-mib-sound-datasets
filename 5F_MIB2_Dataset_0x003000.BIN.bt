//------------------------------------------------
//--- 010 Editor v12.0 Binary Template
//
//      File: 0x003000.BIN
//   Authors: Alex Strelets
//   Version: 0.3
//   Purpose: Parse the contents of the MIB2 Sound Channels and Effects
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 0.1 - Initial version
//            0.2 - Limiters added
//            0.3 - MIB1 vs MIB2 data sync
//------------------------------------------------

BigEndian();

string getSignalflow(int type) {
    switch (type) {
        case 0x10: return "2ch (4.0)";
        case 0x20: return "4ch (8.0)";
        case 0x21: return "4ch / 2ch compatible (8.0 / 4.0)";
        case 0x30: return "6ch center sub (9.1)";
        case 0x31: return "6ch center sub / 2/4ch compatible (9.1 / 8.0 / 4.0)";
        case 0x32: return "6ch doublesub (8.2)";
        case 0x33: return "6ch doublesub / 2/4ch compatible (8.2 / 8.0 / 4.0)";
        case 0x34: return "6ch frontwoofer (9.1)";
        case 0x35: return "6ch frontwoofer / 2/4ch compatible (9.1 / 8.0 / 4.0)";
        default:   return "Unknown";    
    }
}

string getFilterType(int type) {
    switch (type) {
        case 0x00: return "Bypass";    
        case 0x01: return "Shelf 1 High";    
        case 0x02: return "Shelf 2 High";    
        case 0x03: return "Shelf 1 Low";   
        case 0x04: return "Shelf 2 Low";    
        case 0x05: return "Peak 1";    
        case 0x06: return "Peak 2";    
        case 0x07: return "Highpass 1";
        case 0x08: return "Highpass 2";
        case 0x09: return "Lowpass 1";
        case 0x0A: return "Lowpass 2";
        case 0x10: return "Coefficients";
        default:   return "Unknown";
    }
}

typedef struct {
    ubyte type <bgcolor=cAqua, read=getFilterType>;
    ubyte quality <bgcolor=cLtGreen>;   // [0.2 .. 5]
    ushort frequency <bgcolor=cGreen>;  // [20 .. 20000]
    ubyte gainOffset <bgcolor=cDkAqua>; // [-6 .. +6]
    ubyte maxGain <bgcolor=cDkAqua>;    // [0  .. 15]
} EQ;

typedef struct {
    ubyte type <bgcolor=cAqua, read=getFilterType>;
    ubyte quality <bgcolor=cLtGreen>;
    ushort frequency <bgcolor=cGreen>;
    ubyte gain[19] <bgcolor=cDkAqua>;
} EQ2;

typedef struct {
    ubyte type <bgcolor=cAqua, read=getFilterType>;
    ubyte quality <bgcolor=cLtGreen>;
    ushort frequency <bgcolor=cGreen>;
    byte gain <bgcolor=cDkAqua>; // [-12.5 .. 12.5]
} EQ3;

float calcGain (byte value) {
    return (float) value / 12.5;
}

float calcAbsGain (ubyte value) {
    return (float) value / 12.5;
}

void printEQ2(EQ2 &s, string name, int unknownFlag) {
    Printf("\n%s\nType\tQuality\tFrequency\n", name);
    Printf("==================================\n");
    Printf("%s\t%7g\t %6gHz\n", 
        getFilterType(s.type), 
        s.quality / 5, 
        s.frequency); 
    Printf("==================================\n");
    if (!unknownFlag) {
        Printf("Volume:\t");
        for (i = 0; i < 19; i++) {
            Printf("%5g ", 18 - i);
        }
        Printf("\n");
    }
        Printf("Gain:\t");
        for (i = 0; i < 19; i++) {
            Printf("%5.2f ", calcAbsGain(s.gain[i])); 
        }
    Printf("\n");
}

byte Signalflow <bgcolor=cDkGreen, read=getSignalflow>;
EQ ToneControls[5];
ubyte Subwoofer_maxGain <bgcolor=cLtYellow>; // subwoofer gain ???
EQ2 LoudnessLow;
EQ2 LoudnessHigh;
struct {
    ubyte value[19] <bgcolor=cGray>;
} GALA[7];
EQ2 UnknownFilter_1;
EQ2 UnknownFilter_2;
struct {
    EQ3 Filter1;
    ubyte Filter1_coefficients[16] <bgcolor=cDkGray>;
    EQ3 Filter2;
    ubyte Filter2_coefficients[16] <bgcolor=cDkGray>;
    EQ3 Filter3;
    ubyte Filter3_coefficients[16] <bgcolor=cDkGray>;
    EQ3 Filter4;
    EQ3 Filter5;
    EQ3 Filter6;
    EQ3 Filter7;
    byte Gain <bgcolor=cLtYellow>;
    ubyte Delay <bgcolor=cYellow>;
    ubyte Phase <bgcolor=cDkYellow>;
} CarEQ[12];



FSeek(0x50D);

// one of those bytes could be "Limiter THDmax" [0 .. 30]
ubyte unknown_20 <bgcolor=cPurple>;
ubyte unknown_21 <bgcolor=cPurple>;
ubyte unknown_22 <bgcolor=cPurple>;

struct {
    ubyte attackTime <bgcolor=cDkGreen>;
    ushort releaseTime <bgcolor=cGreen>;
    ubyte treshold <bgcolor=cLtGreen>;
    ubyte holdTime <bgcolor=cAqua>;
} Limiters[6];

FSeek(FileSize() - 4);

struct {
    char major <bgcolor=cDkBlue>;
    char minor <bgcolor=cDkBlue>;
} DatasetVersion;
ushort checksum <bgcolor=cDkRed>;

////////////////////////
/// PARSING FINISHED ///
////////////////////////

local int i = 0;
local int j = 0;
local int k = 0;

Printf("\nSIGNAL FLOW: %s\n", getSignalflow(Signalflow));

Printf("\nTONE CONTROLS\nType\tQuality\tFrequency\t  MaxGain\tGainOffset\n");
Printf("===========================================================\n");
for (i = 0; i < 5; i++) {
    Printf("%s\t%7g\t %6gHz\t  %7.2f\t%10.2f\n",
        getFilterType(ToneControls[i].type), 
        ToneControls[i].quality / 5, 
        ToneControls[i].frequency, 
        (float) ToneControls[i].maxGain / 15,
        ToneControls[i].gainOffset / 12);
}
Printf("===========================================================\n");
Printf("Subwoofer\t\t\t  %7.2f\n", Subwoofer_maxGain / 15);

printEQ2(LoudnessLow, "LOUDNESS LOW", false);
printEQ2(LoudnessHigh, "LOUDNESS HIGH", false);

Printf("\nGALA (SPEED-DEPENDENT VOLUME CONTROL)");
Printf("\nLevel\t Gain\n");
Printf("==========================================");
Printf("==========================================");
Printf("==========================================\n");
for ( i = 0; i < 7; i++ ) {
    Printf("%i\t", i+1);
    for ( j = 0; j < 19; j++ ) {
        Printf("%5.2f ", calcAbsGain(GALA[i].value[j]));
    }
    Printf("\n");
};
Printf("==========================================");
Printf("==========================================");
Printf("==========================================\n");

printEQ2(UnknownFilter_1, "UNKNOWN FILTER 1", true);
printEQ2(UnknownFilter_2, "UNKNOWN FILTER 2", true);

Printf("\n\n");
for (j = 0; j < 2; j++) {
    Printf("[ CarEQ%i ]\n\n", j+1);
    for (i = 0; i < 6; i++) {
        k = j * 6 + i;
        Printf("CHANNEL %i [ Gain: %5.2f Delay: %2gms Phase: %3gÂ°]\n", 
            i+1, 
            calcGain(CarEQ[k].Gain), 
            CarEQ[k].Delay, 
            CarEQ[k].Phase > 0 ? 180 : 0);
        Printf("------------------------------------------------\n");
        Printf("Type\tQuality\t Frequency\t       Gain\n");        
        Printf("================================================\n");
        Printf("%s\t%7g\t  %6gHz\t      %5.2f\n", 
            getFilterType(CarEQ[k].Filter1.type), 
            CarEQ[k].Filter1.quality / 5, 
            CarEQ[k].Filter1.frequency,
            calcGain(CarEQ[k].Filter1.gain)); 
        Printf("%s\t%7g\t  %6gHz\t      %5.2f\n", 
            getFilterType(CarEQ[k].Filter2.type), 
            CarEQ[k].Filter2.quality / 5, 
            CarEQ[k].Filter2.frequency,
            calcGain(CarEQ[k].Filter2.gain)); 
        Printf("%s\t%7g\t  %6gHz\t      %5.2f\n", 
            getFilterType(CarEQ[k].Filter3.type), 
            CarEQ[k].Filter3.quality / 5, 
            CarEQ[k].Filter3.frequency,
            calcGain(CarEQ[k].Filter3.gain)); 
        Printf("%s\t%7g\t  %6gHz\t      %5.2f\n", 
            getFilterType(CarEQ[k].Filter4.type), 
            CarEQ[k].Filter4.quality / 5, 
            CarEQ[k].Filter4.frequency,
            calcGain(CarEQ[k].Filter4.gain)); 
        Printf("%s\t%7g\t  %6gHz\t      %5.2f\n", 
            getFilterType(CarEQ[k].Filter5.type), 
            CarEQ[k].Filter5.quality / 5, 
            CarEQ[k].Filter5.frequency,
            calcGain(CarEQ[k].Filter5.gain)); 
        Printf("%s\t%7g\t  %6gHz\t      %5.2f\n", 
            getFilterType(CarEQ[k].Filter6.type), 
            CarEQ[k].Filter6.quality / 5, 
            CarEQ[k].Filter6.frequency,
            calcGain(CarEQ[k].Filter6.gain)); 
        Printf("%s\t%7g\t  %6gHz\t      %5.2f\n", 
            getFilterType(CarEQ[k].Filter7.type), 
            CarEQ[k].Filter7.quality / 5, 
            CarEQ[k].Filter7.frequency,
            calcGain(CarEQ[k].Filter7.gain)); 
        Printf("================================================\n\n");
    }
}

Printf("LIMITERS\n");
Printf("Channel\tAttack\tRelease\tTreshold\t   Hold\n");
Printf("========================================================\n");
for (i = 0; i < 6; i++) {
    Printf("%i\t  %4.1f\t   %4g\t     %3g\t   %4.1f\n", 
        i+1,
        Limiters[i].attackTime / 20, // [0.5 .. 20]
        Limiters[i].releaseTime,     // [5 .. 2000]
        Limiters[i].treshold / -24,   // [-24 ..  0]
        Limiters[i].holdTime / 20    // [0.5 .. 20]
    );
}
Printf("========================================================");


local ushort file_checksum = Checksum(CHECKSUM_CRCCCITT, 0, FileSize() - 2, -1, -1); // algo, size, length, poly, init 
Printf("\n\nFILE CHECKSUM: %.04X", file_checksum);  
